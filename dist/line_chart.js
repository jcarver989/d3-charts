// Generated by CoffeeScript 1.10.0
var LineChart,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

LineChart = (function(superClass) {
  extend(LineChart, superClass);

  function LineChart(selector, options) {
    if (options == null) {
      options = {};
    }
    LineChart.__super__.constructor.call(this, selector, options);
    this.line = d3.svg.line().interpolate("cardinal").x((function(_this) {
      return function(d) {
        return _this.x(extractX(d));
      };
    })(this)).y((function(_this) {
      return function(d) {
        return _this.y(extractY(d));
      };
    })(this));
    this.area = d3.svg.area().interpolate("cardinal").x((function(_this) {
      return function(d) {
        return _this.x(extractX(d));
      };
    })(this)).y((function(_this) {
      return function(d) {
        return _this.y(extractY(d));
      };
    })(this)).y0(this.height);
  }

  LineChart.prototype.drawCircles = function(lines, data, tooltips) {
    var circles, newCircles, tip;
    circles = lines.selectAll("circle").data(function(line) {
      var d, i, len, ref;
      data = [];
      if (line.dots !== false) {
        ref = line.data;
        for (i = 0, len = ref.length; i < len; i++) {
          d = ref[i];
          d.label = line.label;
          data.push(d);
        }
      }
      return data;
    });
    circles.transition().delay(200).attr("cx", (function(_this) {
      return function(d) {
        return _this.x(extractX(d));
      };
    })(this)).attr("cy", (function(_this) {
      return function(d) {
        return _this.y(extractY(d));
      };
    })(this));
    newCircles = circles.enter().append("circle").attr("class", function(d) {
      return "dot " + d.label;
    }).attr("r", 6).attr("cx", (function(_this) {
      return function(d) {
        return _this.x(extractX(d));
      };
    })(this)).attr("cy", (function(_this) {
      return function(d) {
        return _this.y(extractY(d));
      };
    })(this));
    if (tooltips) {
      tip = (this.tip || (this.tip = new Tooltip(document)));
      newCircles.on("mouseover", function(d) {
        tip.html(d[1]);
        return tip.show(this);
      }).on("mouseout", function(d) {
        return tip.hide();
      });
    }
    return circles.exit().remove();
  };

  LineChart.prototype.drawLines = function(enter, update) {
    enter.append("path").attr("class", function(d) {
      return "line " + d.label;
    }).attr("d", (function(_this) {
      return function(d) {
        return _this.line(d.data);
      };
    })(this));
    return update.select(".line").transition().delay(200).attr("d", (function(_this) {
      return function(d) {
        return _this.line(d.data);
      };
    })(this));
  };

  LineChart.prototype.drawAreas = function(enter, update) {
    enter.filter(function(d) {
      return d.area !== false;
    }).append("path").attr("class", function(d) {
      return "area " + d.label;
    }).attr("d", (function(_this) {
      return function(d) {
        return _this.area(d.data);
      };
    })(this));
    return update.filter(function(d) {
      return d.area !== false;
    }).select(".area").transition().delay(200).attr("d", (function(_this) {
      return function(d) {
        return _this.area(d.data);
      };
    })(this));
  };

  LineChart.prototype.draw = function(lines) {
    var allPoints, flattened, line, newLines;
    allPoints = (function() {
      var i, len, results;
      results = [];
      for (i = 0, len = lines.length; i < len; i++) {
        line = lines[i];
        results.push(line.data);
      }
      return results;
    })();
    flattened = d3.merge(allPoints);
    this.x.domain(d3.extent(flattened, extractX));
    this.y.domain([0, d3.max(flattened, extractY)]);
    this.drawAxes();
    lines = this.svg.selectAll(".lineGroup").data(lines, function(d) {
      return d.label;
    });
    newLines = lines.enter().append("g").attr("class", "lineGroup");
    lines.exit().remove();
    this.drawLines(newLines, lines);
    if (this.options.area) {
      this.drawAreas(newLines, lines);
    }
    if (this.options.dots) {
      return this.drawCircles(lines, allPoints, this.options.tooltips);
    }
  };

  return LineChart;

})(AbstractChart);
