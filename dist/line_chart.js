// Generated by CoffeeScript 1.7.1
var LineChart,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

LineChart = (function(_super) {
  __extends(LineChart, _super);

  function LineChart(selector, options) {
    this.options = options != null ? options : {};
    LineChart.__super__.constructor.call(this, selector, options);
    this.line = d3.svg.line().x((function(_this) {
      return function(d) {
        return _this.x(extractX(d));
      };
    })(this)).y((function(_this) {
      return function(d) {
        return _this.y(extractY(d));
      };
    })(this));
    this.area = d3.svg.area().x((function(_this) {
      return function(d) {
        return _this.x(extractX(d));
      };
    })(this)).y((function(_this) {
      return function(d) {
        return _this.y(extractY(d));
      };
    })(this)).y0(this.height);
    this.lineColors = new ColorManager();
    this.areaColors = new ColorManager();
  }

  LineChart.prototype.drawCircles = function(lines, data) {
    var circles;
    circles = lines.selectAll("circle").data((function(_this) {
      return function(line) {
        var color, d, _i, _len;
        color = _this.lineColors.getOrSet(line.label);
        data = line.data;
        for (_i = 0, _len = data.length; _i < _len; _i++) {
          d = data[_i];
          d.color = color;
        }
        return data;
      };
    })(this));
    circles.transition().delay(200).attr("cx", (function(_this) {
      return function(d) {
        return _this.x(extractX(d));
      };
    })(this)).attr("cy", (function(_this) {
      return function(d) {
        return _this.y(extractY(d));
      };
    })(this));
    circles.enter().append("circle").attr("class", "dot").attr("fill", function(d, i) {
      return d.color;
    }).attr("r", 5).attr("cx", (function(_this) {
      return function(d) {
        return _this.x(extractX(d));
      };
    })(this)).attr("cy", (function(_this) {
      return function(d) {
        return _this.y(extractY(d));
      };
    })(this));
    return circles.exit().remove();
  };

  LineChart.prototype.drawLines = function(enter, update) {
    enter.append("path").attr("class", "line").attr("stroke", (function(_this) {
      return function(d, i) {
        return _this.lineColors.getOrSet(d.label);
      };
    })(this)).attr("d", (function(_this) {
      return function(d) {
        return _this.line(d.data);
      };
    })(this));
    return update.select(".line").transition().delay(200).attr("d", (function(_this) {
      return function(d) {
        return _this.line(d.data);
      };
    })(this));
  };

  LineChart.prototype.drawAreas = function(enter, update) {
    enter.append("path").attr("class", "area").attr("fill", (function(_this) {
      return function(d, i) {
        return _this.areaColors.getOrSet(d.label);
      };
    })(this)).attr("d", (function(_this) {
      return function(d) {
        return _this.area(d.data);
      };
    })(this));
    return update.select(".area").transition().delay(200).attr("d", (function(_this) {
      return function(d) {
        return _this.area(d.data);
      };
    })(this));
  };

  LineChart.prototype.assignColor = function(line) {
    if (line.color) {
      this.lineColors.set(line.label, line.color);
    } else {
      this.lineColors.getOrSet(line.label);
    }
    if (line.area_color) {
      return this.areaColors.set(line.label, line.area_color);
    } else {
      return this.areaColors.set(line.label, this.lineColors.getOrSet(line.label));
    }
  };

  LineChart.prototype.draw = function(lines) {
    var data, flattened, i, line, newLines, _i, _len;
    data = [];
    for (i = _i = 0, _len = lines.length; _i < _len; i = ++_i) {
      line = lines[i];
      data.push(line.data);
      this.assignColor(line);
    }
    flattened = d3.merge(data);
    this.x.domain(d3.extent(flattened, extractX));
    this.y.domain([0, d3.max(flattened, extractY)]);
    this.drawAxes();
    lines = this.svg.selectAll(".lineGroup").data(lines, function(d) {
      return d.label;
    });
    newLines = lines.enter().append("g").attr("class", "lineGroup");
    lines.exit().remove();
    this.drawLines(lines, newLines);
    if (this.options.area) {
      this.drawAreas(lines, newLines);
    }
    if (this.options.dots) {
      return this.drawCircles(lines, data);
    }
  };

  return LineChart;

})(AbstractChart);
